package org.jetbrains.plugins.typeSearch


import com.intellij.ide.actions.searcheverywhere.{FoundItemDescriptor, SearchEverywhereContributor, SearchEverywhereContributorFactory, WeightedSearchEverywhereContributor}
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.progress.ProgressIndicator
import com.intellij.openapi.project.Project
import com.intellij.psi.PsiMethod
import com.intellij.psi.search.GlobalSearchScope
import com.intellij.serviceContainer.AlreadyDisposedException
import com.intellij.util.SlowOperations.allowSlowOperations
import com.intellij.util.{Processor, ThrowableRunnable}
import org.jetbrains.plugins.scala.caches.ScalaShortNamesCacheManager
import TypeSearchContributor.inkuireService
import org.virtuslab.inkuire.engine.common.model.ExternalSignature
import org.virtuslab.inkuire.engine.common.service.ScalaExternalSignaturePrettifier


import java.io.File
import javax.swing.ListCellRenderer
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.language.postfixOps

class StdFunctionRef(val externalSignature: ExternalSignature) {
  val encoder = new OperatorCharacterEncoder()
  val getPrettyName: String = externalSignature.name.split("\\$").apply(0)

  val getCorrectPackageName: String = {
    val pom = (externalSignature.packageName + "." + getPrettyName).replace('#', '.')
    val notEncodedStr = pom.substring(0, pom.lastIndexOf("."))

    encoder.encodeString(notEncodedStr)
  }

  // Methods in Intellij's PSI have different signature than one generated by scaladoc
  // with the flag -Ygenerate-inkuire
  val getCorrectPSIName: String = {
    val pom = (externalSignature.packageName + "." + getPrettyName).replace('#', '.')
    val notEncodedStr = pom.substring(pom.lastIndexOf(".") + 1)

    encoder.encodeString(notEncodedStr)
  }
}

class UserInputParsed(val userInput: String) {
  val pattern: String = userInput.split("@").apply(0).trim
  val packages: Array[String] = {
    try {
      userInput
        .split("@")
        .apply(1)
        .trim
        .split("\\s+")
        .map(s => s.trim)
    }
    catch {
      case _: ArrayIndexOutOfBoundsException => Array.empty
    }
  }
}

object TypeSearchContributor {
  val file = new File("./resources")
  val inkuireService: Future[InkuireService] = Future {
    new InkuireService(file.toURI.toURL.toString)
  }
  var project: Option[Project] = None

  class Factory extends SearchEverywhereContributorFactory[AnyRef] {
    override def createContributor(initEvent: AnActionEvent): SearchEverywhereContributor[AnyRef] = {
      project = Some(initEvent.getProject)
      (new TypeSearchContributor).asInstanceOf[SearchEverywhereContributor[AnyRef]]
    }
  }
}

class TypeSearchContributor extends WeightedSearchEverywhereContributor[PsiMethod] {
  val cellRenderer = new TypeSearchListCellRenderer

  override def getElementsRenderer: ListCellRenderer[_ >: Any] =
    (new TypeSearchListCellRenderer).asInstanceOf[ListCellRenderer[_ >: Any]]

  override def getSearchProviderId: String = getClass.getSimpleName

  override def getGroupName: String = "Type Search"

  override def getSortWeight = 1000

  // default is false
  override def isShownInSeparateTab: Boolean = true

  // default is true
  override def showInFindResults(): Boolean = false

  // Simple accuracy measure
  def calculateWeightOfMatch(pattern: String, element: StdFunctionRef): Int = {
    val patternParameters = pattern.split("=>").map(s => s.trim)
    val prettifier = new ScalaExternalSignaturePrettifier
    val elementParametersStringified = prettifier.prettify(element.externalSignature)

    val weight = {
      if (elementParametersStringified == pattern) {
        100
      }
      else {
        var ctr = 0
        for (parameter <- patternParameters) {
          val isMatch = if (elementParametersStringified.contains(parameter)) 1 else 0
          ctr += isMatch
        }
        ctr
      }
    }

    weight
  }

  private def findPSIsForResult(resultRef: StdFunctionRef, packages: Array[String]): PsiMethod = {
    val FQClassName: String = resultRef.getCorrectPackageName

    // Some names contain number of arguments so we want to get rid of it
    val FQName: String = resultRef.getCorrectPSIName


    def getLibNameFromMethod(psiMethod: PsiMethod): String = {
      if (psiMethod == null) {
        return ""
      }

      psiMethod
        .getContainingFile
        .getVirtualFile
        .getCanonicalPath
        .split("!")
        .apply(0)
        .split("/")
        .last
    }

    def findMethodByFQN(scalaShortNamesCacheManager: ScalaShortNamesCacheManager,
                        projectWithLibrariesScope: GlobalSearchScope): Option[PsiMethod] = {
      try {
        scalaShortNamesCacheManager
          .getClassesByFQName(FQClassName, projectWithLibrariesScope)
          .flatMap(_.getAllMethods)
          .filter(
            x => packages.foldLeft(false)((acc: Boolean, p: String) => acc | getLibNameFromMethod(x).contains(p)) |
              packages.isEmpty
          )
          .find(_.getName == FQName)
      }
      catch {
        case _: NullPointerException => None
      }
    }

    try {
      val projectEvent = TypeSearchContributor.project.get
      val scalaShortNamesCacheManager = ScalaShortNamesCacheManager.getInstance(projectEvent)
      val otherProjectScope = GlobalSearchScope.allScope(projectEvent)

      findMethodByFQN(scalaShortNamesCacheManager, otherProjectScope).orNull
    }
    catch {
      case _: AlreadyDisposedException => null
      case _: NullPointerException => null
    }
  }

  override def fetchWeightedElements(userInput: String, progressIndicator: ProgressIndicator,
                                     consumer: Processor[_ >: FoundItemDescriptor[PsiMethod]]): Unit = {
    val parsedInput = new UserInputParsed(userInput)
    val results = Await.result(inkuireService, Duration.apply(5, "s")).query(parsedInput.pattern)

    for (result <- results) {
      class MyRunnable extends Runnable {
        override def run(): Unit = {
          val resultRef: StdFunctionRef = new StdFunctionRef(result)
          val weight = calculateWeightOfMatch(parsedInput.pattern, resultRef)
          val psiMethod = findPSIsForResult(resultRef, parsedInput.packages)

          if (psiMethod != null) {
            val itemDescriptor = new FoundItemDescriptor[PsiMethod](psiMethod, weight)

            consumer.process(itemDescriptor)
          }
        }
      }

      ApplicationManager.getApplication.runReadAction(new MyRunnable)
    }
  }

  override def processSelectedItem(selected: PsiMethod, modifiers: Int, searchText: String): Boolean = {
    class MyThread extends ThrowableRunnable[Throwable] {
      override def run(): Unit = {
        selected match {
          case null => println("psiMethodToNavigate is null")
          case _ => selected.navigate(true)
        }
      }
    }

    allowSlowOperations(new MyThread)
    true // close SEWindow
  }

  override def getDataForItem(element: PsiMethod, dataId: String): Option[Any] = null
}